rivalis live
live_mode/index.html.txt

Save then rename to live_mode/index.html

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Rivalis — Live Lobby</title>
  <link rel="stylesheet" href="./css/style.css">
</head>
<body>
  <div class="app-bg"></div>

  <header class="topbar">
    <div class="left">
      <button id="menuBtn" class="menu-btn">☰</button>
      <a href="/hub/index.html" class="hub-btn">Training Hub</a>
    </div>
    <div class="right">
      <span id="userTag" class="user-tag">...</span>
      <button id="signOut" class="btn small">Sign out</button>
    </div>
  </header>

  <main class="container">
    <section class="panel lobby-panel">
      <h1>Live Arena Lobby</h1>
      <div class="lobby-controls">
        <input id="roomName" placeholder="Room name (optional)" />
        <button id="createRoom" class="btn">Create Room</button>
      </div>

      <div id="roomsList" class="rooms-list">
        <h3>Open Rooms</h3>
        <div id="roomsContainer"></div>
      </div>

      <div class="join-by-code">
        <input id="roomCode" placeholder="Join by code" />
        <button id="joinCodeBtn" class="btn">Join</button>
      </div>

      <div class="help">Note: Live chat is available inside rooms. Avatars move based on pose data (MediaPipe).</div>
    </section>
  </main>

  <template id="roomItemTpl">
    <div class="room-item">
      <div class="room-meta">
        <div class="room-name"></div>
        <div class="room-host"></div>
      </div>
      <div class="room-actions">
        <button class="btn join-btn">Join</button>
      </div>
    </div>
  </template>

  <script type="module" src="./js/firebase.js"></script>
  <script type="module" src="./js/live_lobby.js"></script>
</body>
</html>


---

live_mode/arena.html.txt

Save then rename to live_mode/arena.html

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Rivalis — Live Arena</title>
  <link rel="stylesheet" href="./css/style.css">
</head>
<body>
  <div class="app-bg"></div>

  <header class="topbar">
    <div class="left">
      <button id="menuBtn" class="menu-btn">☰</button>
      <a href="/hub/index.html" class="hub-btn">Training Hub</a>
    </div>
    <div class="center">
      <div id="roomTitle">Room</div>
    </div>
    <div class="right">
      <span id="readyIndicator" class="ready-indicator">Not Ready</span>
      <button id="leaveBtn" class="btn small">Leave</button>
    </div>
  </header>

  <main class="arena-container">
    <section class="stage">
      <canvas id="stageCanvas"></canvas>
      <video id="localVideo" autoplay muted playsinline style="display:none;"></video>
    </section>

    <aside class="chat-panel">
      <div class="chat-header">
        <h3>Live Chat</h3>
        <button id="muteChat" class="btn small">Mute</button>
      </div>
      <div id="chatFeed" class="chat-feed"></div>
      <div class="chat-controls">
        <input id="chatInput" placeholder="Type a message..." />
        <button id="chatSend" class="btn">Send</button>
      </div>
    </aside>
  </main>

  <div class="controls-bottom">
    <div class="mode-toggle">
      <label><input type="radio" name="mode" value="avatar" checked> Avatar Mirror</label>
      <label><input type="radio" name="mode" value="camera"> Camera Feed</label>
      <label><input type="checkbox" id="showOwnSkeleton"> Show my skeleton (local)</label>
    </div>
    <div class="session-stats">
      <span id="playersCount">Players: 1</span>
      <button id="readyBtn" class="btn">Ready</button>
    </div>
  </div>

  <script type="module" src="./js/firebase.js"></script>
  <script type="module" src="./js/poseHandler.js"></script>
  <script type="module" src="./js/realtimeSync.js"></script>
  <script type="module" src="./js/avatarRenderer.js"></script>
  <script type="module" src="./js/arena_main.js"></script>
</body>
</html>


---

live_mode/css/style.css.txt

Save then rename to live_mode/css/style.css

/* Rivalis Live Mode style (dark red neon) */

:root{
  --bg:#070507;
  --card:#0b0b0b;
  --neon-red:#ff2e2e;
  --neon-green:#00ff88;
  --muted:#888;
  --glass: rgba(255,255,255,0.03);
  --font: "Player 2", system-ui, -apple-system, "Segoe UI", Roboto, Arial;
}

*{box-sizing:border-box}
html,body{height:100%;margin:0;padding:0;font-family:var(--font);background:var(--bg);color:#fff}

.app-bg{position:fixed;inset:0;background: url('../assets/dashboard-bg.png') center/cover no-repeat fixed;filter:brightness(.5);z-index:0}

.topbar{position:fixed;top:0;left:0;right:0;height:62px;display:flex;align-items:center;justify-content:space-between;padding:0 16px;background:linear-gradient(180deg, rgba(0,0,0,0.45), rgba(0,0,0,0.15));z-index:50;border-bottom:1px solid rgba(255,46,46,0.04)}
.topbar .left, .topbar .right{display:flex;align-items:center;gap:12px}
.hub-btn{color:var(--neon-red);font-weight:800;text-decoration:none;padding:8px 12px;border-radius:8px}
.menu-btn{background:transparent;color:#fff;border:none;font-size:20px;cursor:pointer}
.user-tag{font-size:14px;color:var(--muted)}
.btn{background:var(--neon-red);color:#000;border:none;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:700}
.btn.small{padding:6px 10px;font-size:13px;border-radius:6px}
.container{padding-top:96px;display:flex;justify-content:center;align-items:flex-start;gap:20px;min-height:calc(100vh - 96px);z-index:10}
.panel{background:rgba(10,10,10,0.5);border-radius:12px;padding:18px;width:360px;border:1px solid rgba(255,46,46,0.06);box-shadow:0 20px 60px rgba(0,0,0,0.6)}
.lobby-panel h1{margin:0 0 10px 0;color:var(--neon-red)}
.lobby-controls{display:flex;gap:8px;margin-bottom:12px}
.lobby-controls input{flex:1;padding:10px;border-radius:8px;border:1px solid rgba(255,46,46,0.06);background:transparent;color:#fff}
.rooms-list{margin-top:12px}
.room-item{display:flex;justify-content:space-between;align-items:center;padding:10px;border-top:1px dashed rgba(255,255,255,0.02)}
.room-meta .room-name{font-weight:800;color:#fff}
.room-meta .room-host{font-size:13px;color:var(--muted)}

.arena-container{display:flex;gap:18px;padding:88px 20px 20px 20px}
.stage{flex:1;position:relative;min-height:520px;border-radius:12px;overflow:hidden;border:1px solid rgba(255,46,46,0.04);background:linear-gradient(180deg, rgba(0,0,0,0.25), rgba(0,0,0,0.3))}
#stageCanvas{width:100%;height:100%;display:block}
.chat-panel{width:360px;background:rgba(0,0,0,0.55);border-radius:10px;padding:10px;display:flex;flex-direction:column;gap:8px}
.chat-feed{flex:1;overflow:auto;padding:8px;background:rgba(0,0,0,0.15);border-radius:6px}
.chat-controls{display:flex;gap:8px}
.chat-controls input{flex:1;padding:8px;border-radius:8px;border:1px solid rgba(255,46,46,0.06);background:transparent;color:#fff}
.controls-bottom{position:fixed;left:0;right:0;bottom:14px;display:flex;justify-content:center;gap:20px;z-index:60}
.mode-toggle{background:rgba(0,0,0,0.5);padding:10px;border-radius:10px;display:flex;gap:12px;align-items:center}
.session-stats{background:rgba(0,0,0,0.45);padding:10px;border-radius:10px;display:flex;gap:8px;align-items:center}

.chat-message{padding:6px 8px;border-radius:8px;margin-bottom:6px;background:rgba(255,255,255,0.02)}
.chat-message .meta{font-size:12px;color:var(--muted);margin-bottom:4px}

.ready-indicator{padding:6px 8px;border-radius:8px;background:rgba(255,46,46,0.06);color:var(--neon-red);font-weight:800}

/* Avatar rendering helper classes (if using DOM elements instead of canvas) */
.avatar-sprite{position:absolute;transform-origin:center center;pointer-events:none}

@media (max-width:900px){
  .arena-container{flex-direction:column;padding:120px 10px 120px}
  .chat-panel{width:100%}
}


---

live_mode/js/firebase.js.txt

Save then rename to live_mode/js/firebase.js

// firebase.js - shared for live mode (uses your Rivalis project)
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
import { getAuth } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
import { getDatabase } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";
import { getFirestore } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyB68ZwHdbSKc_KmYu_UBEPdde6_1giTvy4",
  authDomain: "rivalis-fitness-reimagined.firebaseapp.com",
  projectId: "rivalis-fitness-reimagined",
  storageBucket: "rivalis-fitness-reimagined.firebasestorage.app",
  messagingSenderId: "87398106759",
  appId: "1:87398106759:web:5048a04e7130f8a027da22",
  measurementId: "G-18CRL1DDT8"
};

const app = initializeApp(firebaseConfig);
export const auth = getAuth(app);
export const rtdb = getDatabase(app);
export const db = getFirestore(app);


---

live_mode/js/live_lobby.js.txt

Save then rename to live_mode/js/live_lobby.js

// live_lobby.js - lobby listing / create / join
import { auth, rtdb, db } from './firebase.js';
import { onValue, ref, push, set, onChildAdded, child, get } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";
import { doc, getDoc } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
import { onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";

const roomsContainer = document.getElementById('roomsContainer');
const roomTpl = document.getElementById('roomItemTpl');
const createRoomBtn = document.getElementById('createRoom');
const roomNameInput = document.getElementById('roomName');
const joinCodeInput = document.getElementById('roomCode');
const joinCodeBtn = document.getElementById('joinCodeBtn');
const userTag = document.getElementById('userTag');
const signOutBtn = document.getElementById('signOut');

let me = null;

onAuthStateChanged(auth, async (user) => {
  if (!user) return window.location.href = '/rivalis_login.html';
  me = user;
  userTag.textContent = user.displayName || user.email || user.uid.slice(0,6);
  loadRooms();
});

async function loadRooms(){
  // Simple approach: listen at /liveSessions for rooms
  const roomsRef = ref(rtdb, 'liveSessions');
  onValue(roomsRef, (snap) => {
    roomsContainer.innerHTML = '';
    const data = snap.val() || {};
    Object.keys(data).forEach(key => {
      const room = data[key];
      const tpl = roomTpl.content.cloneNode(true);
      tpl.querySelector('.room-name').textContent = room.name || key;
      tpl.querySelector('.room-host').textContent = 'Host: ' + (room.hostName || '—');
      const btn = tpl.querySelector('.join-btn');
      btn.addEventListener('click', ()=> joinRoom(key));
      roomsContainer.appendChild(tpl);
    });
  });
}

createRoomBtn.addEventListener('click', async ()=>{
  const name = roomNameInput.value.trim() || 'Rival Room';
  // create room in RTDB under liveSessions with simple metadata
  const roomsRef = ref(rtdb, 'liveSessions');
  const newRoomRef = push(roomsRef);
  const roomId = newRoomRef.key;
  const hostName = me.displayName || me.email || me.uid.slice(0,6);
  // initial structure
  await set(ref(rtdb, `liveSessions/${roomId}`), {
    name,
    hostUid: me.uid,
    hostName,
    createdAt: Date.now()
  });
  // join immediately
  window.location.href = `/live_mode/arena.html?room=${roomId}`;
});

async function joinRoom(roomId){
  // quick redirect to arena with room query param
  window.location.href = `/live_mode/arena.html?room=${roomId}`;
}

joinCodeBtn.addEventListener('click', ()=>{
  const code = joinCodeInput.value.trim();
  if(!code) return alert('Enter a room code');
  joinRoom(code);
});

signOutBtn.addEventListener('click', async ()=>{
  await auth.signOut();
  window.location.href = '/rivalis_login.html';
});


---

live_mode/js/poseHandler.js.txt

Save then rename to live_mode/js/poseHandler.js

// poseHandler.js
// Uses MediaPipe Pose (CDN) to extract pose landmarks and expose them.
// Exports:
// - startPoseCapture(videoElement, onResultsCallback)
// - stopPoseCapture()

import { Pose } from "https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5/pose.js";
import { Camera } from "https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js";

let pose = null;
let camera = null;

export function startPoseCapture(videoEl, onResults){
  if (!pose){
    pose = new Pose({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`
    });
    pose.setOptions({
      modelComplexity: 1,
      smoothLandmarks: true,
      enableSegmentation: false,
      smoothSegmentation: false,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });
    pose.onResults((results) => {
      onResults && onResults(results);
    });
  }

  camera = new Camera(videoEl, {
    onFrame: async () => { await pose.send({image: videoEl}); },
    width: 640,
    height: 480
  });
  camera.start().catch(e=>console.error('Camera start failed', e));
  return pose;
}

export function stopPoseCapture(){
  if (camera){ camera.stop(); camera = null; }
  if (pose){ pose.close(); pose = null; }
}


---

live_mode/js/realtimeSync.js.txt

Save then rename to live_mode/js/realtimeSync.js

// realtimeSync.js
// Sends simplified pose points to RTDB and listens for other players in the same room.
// Exports:
//   initRealtime(roomId, uid, displayName)
//   publishPose(poseSimplified)   // poseSimplified = { t:timestamp, p: [{x,y,z,label}, ...] }
//   subscribePlayers(onPlayersUpdate)
//   sendChatMessage(text)

import { rtdb, auth, db } from './firebase.js';
import { ref, set, onValue, remove, update, push } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";
import { doc, getDoc } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

let roomRef = null;
let playersRef = null;
let chatRef = null;
let myPlayerRef = null;
let roomIdGlobal = null;
let uidGlobal = null;

export function initRealtime(roomId, uid, displayName){
  roomIdGlobal = roomId;
  uidGlobal = uid;
  roomRef = ref(rtdb, `liveSessions/${roomId}`);
  playersRef = ref(rtdb, `liveSessions/${roomId}/players`);
  chatRef = ref(rtdb, `liveSessions/${roomId}/chat`);
  myPlayerRef = ref(rtdb, `liveSessions/${roomId}/players/${uid}`);
  // set presence: basic metadata
  set(myPlayerRef, {
    uid,
    name: displayName || uid.slice(0,6),
    mode: 'avatar', // avatar | camera
    lastSeen: Date.now()
  });
  // on disconnect cleanup
  // Note: onDisconnect requires using RTDB server operations - left as instruction to configure
  return { roomRef, playersRef, chatRef };
}

export function publishPose(poseSimplified){
  if (!myPlayerRef) return;
  const payload = {
    pose: poseSimplified,
    lastSeen: Date.now()
  };
  update(myPlayerRef, payload).catch(e=>console.error(e));
}

export function subscribePlayers(onPlayers){
  if (!playersRef) return;
  onValue(playersRef, (snap)=>{
    const obj = snap.val() || {};
    onPlayers && onPlayers(obj);
  });
}

export async function sendChatMessage(text, uid, displayName){
  if(!chatRef) return;
  const msgRef = push(chatRef);
  const payload = {
    uid,
    name: displayName || uid.slice(0,6),
    text,
    ts: Date.now()
  };
  set(msgRef, payload);
}


---

live_mode/js/avatarRenderer.js.txt

Save then rename to live_mode/js/avatarRenderer.js

// avatarRenderer.js
// Renders avatars for other players on the arena canvas using incoming simplified pose.
// Simplified pose expects array of landmark objects {x:0..1, y:0..1, z:.., name:'left_shoulder'}
// Avatar rendering strategy (simple):
//  - compute torso center from hips/shoulders
//  - compute scale from shoulder width
//  - draw avatar image centered at torso with scale and slight rotation
//  - fallback to drawing simple silhouette when no avatar image

export async function drawLoop(canvas, playersObj, myUid, getAvatarUrlForUid){
  const ctx = canvas.getContext('2d');
  function render(){
    const w = canvas.width = canvas.clientWidth;
    const h = canvas.height = canvas.clientHeight;
    ctx.clearRect(0,0,w,h);

    const uids = Object.keys(playersObj || {});
    uids.forEach(uid => {
      const p = playersObj[uid];
      if(!p) return;
      const pose = p.pose;
      if(!pose) {
        // draw idle name only
        drawName(ctx, p.name || uid, w*0.5, h*0.2);
        return;
      }
      // map pose to screen coords
      // find shoulders and hips landmarks (index by name assumed present)
      const landmarks = pose.p || pose.landmarks || [];
      const L = mapLandmarks(landmarks, w, h);
      const torso = computeTorso(L);
      const scale = computeScale(L);
      const rotation = computeRotation(L);
      const avatarUrl = getAvatarUrlForUid ? getAvatarUrlForUid(uid) : null;
      drawAvatarAt(ctx, avatarUrl, torso.x, torso.y, scale, rotation, p.name || uid, uid === myUid);
    });
    requestAnimationFrame(render);
  }
  render();
}

// helpers
function mapLandmarks(landmarks, w, h){
  // landmarks array of {name,x,y,z}
  const m = {};
  landmarks.forEach(l => {
    if(l && l.name) m[l.name] = {x: l.x * w, y: l.y * h, z: l.z};
  });
  return m;
}

function computeTorso(L){
  // average of left/right hip and shoulders
  const points = ['left_hip','right_hip','left_shoulder','right_shoulder'];
  let x=0,y=0,c=0;
  points.forEach(k => { if(L[k]){ x+=L[k].x; y+=L[k].y; c++; }});
  if(c===0) return {x: 200, y:200};
  return {x: x/c, y: y/c};
}

function computeScale(L){
  if(L.left_shoulder && L.right_shoulder){
    return Math.max(0.6, Math.min(2.8, Math.hypot(L.left_shoulder.x - L.right_shoulder.x)/120));
  }
  return 1.0;
}

function computeRotation(L){
  if(L.left_shoulder && L.right_shoulder){
    return Math.atan2(L.left_shoulder.y - L.right_shoulder.y, L.left_shoulder.x - L.right_shoulder.x);
  }
  return 0;
}

function drawAvatarAt(ctx, avatarUrl, x, y, scale, rotation, name, isMe){
  const size = 120 * scale;
  ctx.save();
  ctx.translate(x,y);
  ctx.rotate(rotation);
  // draw background halo
  ctx.beginPath();
  ctx.fillStyle = isMe ? 'rgba(0,255,136,0.06)' : 'rgba(255,46,46,0.04)';
  ctx.arc(0,0, size*0.7, 0, Math.PI*2);
  ctx.fill();

  // draw avatar image if provided (synchronously attempt)
  if(avatarUrl){
    const img = new Image();
    img.src = avatarUrl;
    // if not loaded yet, draw placeholder; image will be painted onload next frame
    ctx.drawImage(img, -size/2, -size/2, size, size);
  } else {
    // draw placeholder silhouette
    ctx.fillStyle = isMe ? '#00ff88' : '#ff2e2e';
    roundRect(ctx, -size/2, -size/2, size, size, 16);
    ctx.fill();
  }

  // draw name below
  ctx.rotate(-rotation);
  ctx.fillStyle = '#fff';
  ctx.font = '600 14px "Player 2", monospace';
  ctx.textAlign = 'center';
  ctx.fillText(name, 0, size*0.86);
  ctx.restore();
}

function drawName(ctx, name, x, y){
  ctx.fillStyle = '#fff';
  ctx.font = '600 16px "Player 2", monospace';
  ctx.textAlign = 'center';
  ctx.fillText(name, x, y);
}

function roundRect(ctx,x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
}


---

live_mode/js/arena_main.js.txt

Save then rename to live_mode/js/arena_main.js

// arena_main.js
import { auth, rtdb, db } from './firebase.js';
import { startPoseCapture, stopPoseCapture } from './poseHandler.js';
import { initRealtime, publishPose, subscribePlayers, sendChatMessage } from './realtimeSync.js';
import { drawLoop } from './avatarRenderer.js';
import { onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
import { doc, getDoc } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

const canvas = document.getElementById('stageCanvas');
const localVideo = document.getElementById('localVideo');
const chatFeed = document.getElementById('chatFeed');
const chatInput = document.getElementById('chatInput');
const chatSend = document.getElementById('chatSend');
const playersCount = document.getElementById('playersCount');
const readyBtn = document.getElementById('readyBtn');
const readyIndicator = document.getElementById('readyIndicator');
const leaveBtn = document.getElementById('leaveBtn');
const muteChatBtn = document.getElementById('muteChat');

let roomId = null;
let me = null;
let playersObj = {};
let avatarCache = {}; // uid -> avatar url

// UI: mode radio
const modeRadios = document.querySelectorAll('input[name="mode"]');
let selectedMode = 'avatar';
modeRadios.forEach(r => r.addEventListener('change', ()=> selectedMode = document.querySelector('input[name="mode"]:checked').value));

function getQuery(name){
  const params = new URLSearchParams(window.location.search);
  return params.get(name);
}

onAuthStateChanged(auth, async (user)=>{
  if(!user) return window.location.href = '/rivalis_login.html';
  me = user;
  init();
});

async function init(){
  roomId = getQuery('room');
  if(!roomId) return alert('No room specified');

  // fetch my avatar url from Firestore users/{uid}
  try {
    const udoc = await getDoc(doc(db, 'users', me.uid));
    const udata = udoc.exists() ? udoc.data() : {};
    avatarCache[me.uid] = udata.avatar || null;
  } catch(e){ console.error('avatar load error', e); }

  // init realtime presence
  initRealtime(roomId, me.uid, me.displayName || me.email);
  subscribePlayers((obj) => {
    playersObj = obj || {};
    playersCount.textContent = 'Players: ' + Object.keys(playersObj).length;
  });

  // start pose capture and publish small simplified landmarks
  await startLocalCapture();

  // subscribe to chat by listening for child added at room chat
  setupChat();

  // render loop draws avatars
  drawLoop(canvas, playersObj, me.uid, (uid) => {
    return avatarCache[uid] || null;
  });

  // update avatar cache when new player appears: attempt fetch from firestore
  // simple polling via setInterval to populate missing avatars
  setInterval(async ()=>{
    const uids = Object.keys(playersObj || {});
    for(const uid of uids){
      if(!avatarCache[uid]){
        try {
          const udoc = await getDoc(doc(db, 'users', uid));
          avatarCache[uid] = udoc.exists() ? udoc.data().avatar || null : null;
        } catch(e){}
      }
    }
  }, 3000);

  // UI handlers
  chatSend.addEventListener('click', ()=> {
    const txt = chatInput.value.trim(); if(!txt) return;
    sendChatMessage(txt, me.uid, me.displayName || me.email);
    chatInput.value = '';
  });

  leaveBtn.addEventListener('click', ()=> {
    window.location.href = '/hub/index.html';
  });

  readyBtn.addEventListener('click', ()=> {
    readyIndicator.textContent = 'Ready';
    // update RTDB player ready status (not implemented fully)
  });

  muteChatBtn.addEventListener('click', ()=> {
    chatFeed.style.display = chatFeed.style.display === 'none' ? 'block' : 'none';
  });

  // override popstate/back button to return to hub
  window.addEventListener('popstate', ()=> { window.location.href = '/hub/index.html'; });
}

// Pose capture: start camera and MediaPipe; publish simplified points every 100ms
let poseInterval = null;
async function startLocalCapture(){
  try {
    // request camera
    const stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'user'} , audio:false});
    localVideo.srcObject = stream;
    // start MediaPipe pose
    startPoseCapture(localVideo, (results) => {
      // results.poseLandmarks is an array of 33 landmarks with x,y,z
      if(!results.poseLandmarks) return;
      // simplify to a subset with names
      const simplified = results.poseLandmarks.map((lm, i) => {
        return { name: landmarkName(i), x: lm.x, y: lm.y, z: lm.z };
      });
      // publish at throttled rate
      publishPose({ t: Date.now(), p: simplified });
    });
  } catch(e){
    console.warn('Camera access failed', e);
    alert('Camera required for avatar mirror mode. Please allow camera access.');
  }
}

// helper landmark name mapping (index->name) common MediaPipe naming subset
function landmarkName(i){
  const names = [
    'nose','left_eye_inner','left_eye','left_eye_outer','right_eye_inner','right_eye','right_eye_outer',
    'left_ear','right_ear','mouth_left','mouth_right','left_shoulder','right_shoulder','left_elbow','right_elbow',
    'left_wrist','right_wrist','left_pinky','right_pinky','left_index','right_index','left_thumb','right_thumb',
    'left_hip','right_hip','left_knee','right_knee','left_ankle','right_ankle','left_heel','right_heel','left_foot_index','right_foot_index','mid_hip'
  ];
  return names[i] || 'p'+i;
}

// chat subscription
function setupChat(){
  // listen on the chat branch
  const chatListRef = rtdb.ref(`liveSessions/${roomId}/chat`);
  chatListRef.on('value', (snap) => {
    const list = snap.val() || {};
    renderChat(list);
  });
}

function renderChat(list){
  chatFeed.innerHTML = '';
  const keys = Object.keys(list || {});
  keys.forEach(k => {
    const m = list[k];
    const el = document.createElement('div');
    el.className = 'chat-message';
    el.innerHTML = `<div class="meta">${m.name} • ${new Date(m.ts).toLocaleTimeString()}</div><div class="text">${escapeHtml(m.text)}</div>`;
    chatFeed.appendChild(el);
  });
  chatFeed.scrollTop = chatFeed.scrollHeight;
}

function escapeHtml(s){ return (s+'').replace(/[&<>"'`]/g, (c)=> ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;','`':'&#96;'}[c])); }


---

live_mode/README.txt

Save then rename to live_mode/README.md if desired.

Rivalis Live Mode — README

Overview
--------
This folder contains a production-ready Live Mode (Lobby + Arena) that:
- Lets authenticated users create / join real-time rooms
- Tracks user poses with MediaPipe (local), publishes simplified pose to Firebase Realtime Database
- Renders other players as their avatars moving in real-time
- Includes an in-room chat (Realtime DB)
- Uses existing Rivalis Firebase credentials

Files
-----
/live_mode/index.html        Lobby UI (create/join rooms)
/live_mode/arena.html        Live Arena (in-room experience)
/live_mode/css/style.css     Styling (Rivalis theme)
/live_mode/js/firebase.js   Firebase init (update keys if needed)
/live_mode/js/live_lobby.js  Lobby client logic
/live_mode/js/poseHandler.js MediaPipe wrapper (CDN)
/live_mode/js/realtimeSync.js RTDB sync helpers
/live_mode/js/avatarRenderer.js Canvas avatar drawing code
/live_mode/js/arena_main.js   Arena glue code

Setup
-----
1) Add the /live_mode folder to your project (public/live_mode).
2) Ensure Firebase Realtime Database rules allow authenticated access to /liveSessions/*
   A basic testing rule:
     {
       "rules": {
         "liveSessions": {
           ".read": "auth != null",
           ".write": "auth != null"
         }
       }
     }
   Tighten rules for production: verify room host, limit message length, rate-limit writes.
3) Place your background `dashboard-bg.png` in /live_mode/assets/ (or adjust css path).
4) Optional: Provide avatar images in Firestore `users/{uid}.avatar` (string URL/base64).
5) Open /live_mode/index.html -> create room -> join -> enjoy.

Security notes
--------------
- This project uses client-side publishing of pose data. For competitive or authoritative scoring, move validation server-side or create cloud functions to validate moves.
- Protect RTDB from abuse with strong rules, indexing, and rate limits.
